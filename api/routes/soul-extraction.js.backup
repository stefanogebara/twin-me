/**
 * Soul Signature Extraction Routes - Updated
 *
 * These routes handle real-time extraction of personality insights
 * from connected entertainment platforms AND professional/productivity tools.
 * This is where we discover the authentic self through digital footprints.
 */

import express from 'express';
import RealTimeExtractor from '../services/realTimeExtractor.js';
import spotifyEnhancedExtractor from '../services/spotifyEnhancedExtractor.js';
import youtubeEnhancedExtractor from '../services/youtubeEnhancedExtractor.js';
import { createClient } from '@supabase/supabase-js';
import { decryptToken } from '../services/encryption.js';
import { getValidAccessToken } from '../services/tokenRefresh.js';
import {
  asyncHandler,
  PlatformNotConnectedError,
  PlatformAPIError,
  PlatformTokenExpiredError,
  InsufficientDataError,
  RateLimitError,
  PlatformError
} from '../middleware/errors.js';
import {
  validateUserId,
  validatePlatform,
  requirePlatformConnection,
  validateMultiplePlatforms
} from '../middleware/platformValidation.js';

const router = express.Router();
const extractor = new RealTimeExtractor();

// Initialize Supabase client
// Use SUPABASE_URL (backend) not VITE_SUPABASE_URL (frontend)
const supabase = createClient(
  process.env.SUPABASE_URL || process.env.VITE_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

/**
 * POST /api/soul/extract/platform/:platform
 * Extract soul signature from a specific platform
 *
 * Middleware chain:
 * 1. validateUserId - Ensures userId is provided and valid
 * 2. validatePlatform - Ensures platform is supported
 * 3. requirePlatformConnection - Ensures platform is connected (or throws helpful error)
 */
router.post('/extract/platform/:platform',
  validateUserId,
  validatePlatform,
  requirePlatformConnection,
  asyncHandler(async (req, res) => {
    const { platform } = req.params;
    const { userId } = req.body;

    console.log(`ðŸŽ­ Soul extraction request for ${platform} from user ${userId}`);

    // Get valid access token (will auto-refresh if expired)
    const tokenResult = await getValidAccessToken(userId, platform);

    if (!tokenResult.success) {
      // If token validation fails, try to provide helpful error
      if (tokenResult.error.includes('expired')) {
        throw new PlatformTokenExpiredError(platform, userId, {
          originalError: tokenResult.error
        });
      }
      if (tokenResult.error.includes('No active connection')) {
        throw new PlatformNotConnectedError(platform, userId, {
          originalError: tokenResult.error
        });
      }

      // Don't fall back to sample data - throw proper error
      throw new PlatformNotConnectedError(platform, userId, {
        originalError: tokenResult.error
      });
    }

    const accessToken = tokenResult.accessToken;
    let extraction;

    try {
      switch (platform.toLowerCase()) {
        case 'spotify':
          extraction = await extractor.extractSpotifySignature(accessToken, userId);
          break;

        case 'youtube':
          extraction = await extractor.extractYouTubeSignature(accessToken, userId);
          break;

        case 'netflix':
        case 'steam':
          extraction = await extractor.generateGenericPlatformData(platform, userId);
          break;

        default:
          // This shouldn't happen since validatePlatform middleware should catch it
          throw new PlatformAPIError(platform, 'Extraction not implemented for this platform', 501);
      }
    } catch (extractionError) {
      // Platform API errors
      if (extractionError.response) {
        const status = extractionError.response.status;
        if (status === 429) {
          throw new RateLimitError(platform, '15 minutes', {
            originalError: extractionError.message
          });
        }
        throw new PlatformAPIError(platform, extractionError.message, status);
      }
      // Re-throw if it's already one of our custom errors
      if (extractionError instanceof PlatformError) {
        throw extractionError;
      }
      // Generic extraction error
      throw new PlatformAPIError(platform, extractionError.message);
    }

    // Check if we got enough data
    if (extraction && extraction.dataPointsCount !== undefined && extraction.dataPointsCount < 5) {
      throw new InsufficientDataError(platform, 5, extraction.dataPointsCount, {
        message: 'Need more activity on this platform for meaningful analysis'
      });
    }

    // Update last_sync timestamp in database
    try {
      await supabase
        .from('data_connectors')
        .update({
          last_sync: new Date().toISOString(),
          last_sync_status: extraction.success !== false ? 'success' : 'failed'
        })
        .eq('user_id', userId)
        .eq('provider', platform);
    } catch (dbError) {
      console.warn('âš ï¸ Failed to update last_sync timestamp:', dbError.message);
      // Don't throw - extraction succeeded even if sync timestamp update failed
    }

    res.json({
      success: true,
      platform,
      userId,
      extractedAt: new Date().toISOString(),
      data: extraction,
      usingRealData: !extraction.isMockData,
      dataQuality: extraction.dataPointsCount >= 20 ? 'high' : extraction.dataPointsCount >= 10 ? 'medium' : 'low'
    });
  })
);

/**
 * POST /api/soul/extract/spotify-deep/:userId
 * Enhanced Spotify extraction with 15+ behavioral dimensions
 *
 * This endpoint provides Spotify Wrapped-level insights:
 * - Temporal patterns (night owl vs early bird)
 * - Discovery behavior (explorer vs comfort-zone)
 * - Audio personality (emotional profile, energy levels)
 * - Playlist behavior (organization style)
 * - Genre evolution (taste development over time)
 * - Artist loyalty patterns
 * - Musical sophistication analysis
 * - Overall personality metrics (openness, conscientiousness, authenticity)
 */
router.post('/extract/spotify-deep/:userId', asyncHandler(async (req, res) => {
  const { userId } = req.params;

  console.log(`ðŸŽµ [Spotify Enhanced] Deep extraction request for user ${userId}`);

  // Get valid access token (will auto-refresh if expired)
  const tokenResult = await getValidAccessToken(userId, 'spotify');

  if (!tokenResult.success) {
    throw new PlatformNotConnectedError('spotify', userId, {
      originalError: tokenResult.error,
      message: 'Please connect your Spotify account first'
    });
  }

  const accessToken = tokenResult.accessToken;

  // Perform comprehensive extraction
  const enhancedProfile = await spotifyEnhancedExtractor.extractComprehensiveProfile(accessToken, userId);

  if (!enhancedProfile.success) {
    throw new PlatformAPIError('spotify', enhancedProfile.error || 'Extraction failed');
  }

  // Store enhanced data in database for later analysis
  try {
    await supabase
      .from('user_platform_data')
      .insert({
        user_id: userId,
        platform: 'spotify',
        data_type: 'enhanced_profile',
        raw_data: enhancedProfile,
        extracted_at: new Date().toISOString(),
        processed: false
      });

    console.log(`âœ… [Spotify Enhanced] Profile stored in database`);
  } catch (dbError) {
    console.warn('âš ï¸ [Spotify Enhanced] Failed to store in database:', dbError.message);
    // Continue even if database storage fails
  }

  // Update last_sync timestamp
  try {
    await supabase
      .from('data_connectors')
      .update({
        last_sync: new Date().toISOString(),
        last_sync_status: 'success',
        metadata: {
          enhanced_extraction: true,
          data_quality: enhancedProfile.dataQuality?.quality || 'unknown',
          analyses_performed: 8,
          last_enhanced_sync: new Date().toISOString()
        }
      })
      .eq('user_id', userId)
      .eq('provider', 'spotify');
  } catch (dbError) {
    console.warn('âš ï¸ Failed to update connector metadata:', dbError.message);
  }

  res.json({
    success: true,
    platform: 'spotify',
    extractionType: 'enhanced-comprehensive',
    userId,
    extractedAt: enhancedProfile.extractedAt,
    dataQuality: enhancedProfile.dataQuality,
    data: enhancedProfile,
    message: '15+ behavioral dimensions extracted from Spotify'
  });
}));

/**
 * POST /api/soul/extract/youtube-deep/:userId
 * Enhanced YouTube extraction with 10+ behavioral dimensions
 *
 * This endpoint provides comprehensive YouTube behavioral analysis:
 * - Watch patterns (night owl vs early bird, binge behavior)
 * - Content preferences (educational vs entertainment ratio)
 * - Creator loyalty (consistent vs exploratory)
 * - Learning style (tutorial vs conceptual vs practical)
 * - Curiosity profiling (specialist vs generalist)
 * - Attention patterns (short-form vs long-form preference)
 * - Engagement behavior (active curator vs passive consumer)
 * - Content evolution (how tastes change over time)
 * - Discovery behavior (how you find new content)
 * - Educational depth (learning commitment level)
 * - Overall personality metrics (openness, conscientiousness, intellectual curiosity)
 */
router.post('/extract/youtube-deep/:userId', asyncHandler(async (req, res) => {
  const { userId } = req.params;

  console.log(`ðŸ“º [YouTube Enhanced] Deep extraction request for user ${userId}`);

  // Get valid access token (will auto-refresh if expired)
  const tokenResult = await getValidAccessToken(userId, 'youtube');

  if (!tokenResult.success) {
    throw new PlatformNotConnectedError('youtube', userId, {
      originalError: tokenResult.error,
      message: 'Please connect your YouTube account first'
    });
  }

  const accessToken = tokenResult.accessToken;

  // Perform comprehensive extraction
  const enhancedProfile = await youtubeEnhancedExtractor.extractComprehensiveProfile(accessToken, userId);

  if (!enhancedProfile.success) {
    throw new PlatformAPIError('youtube', enhancedProfile.error || 'Extraction failed');
  }

  // Store enhanced data in database for later analysis
  try {
    await supabase
      .from('user_platform_data')
      .insert({
        user_id: userId,
        platform: 'youtube',
        data_type: 'enhanced_profile',
        raw_data: enhancedProfile,
        extracted_at: new Date().toISOString(),
        processed: false
      });

    console.log(`âœ… [YouTube Enhanced] Profile stored in database`);
  } catch (dbError) {
    console.warn('âš ï¸ [YouTube Enhanced] Failed to store in database:', dbError.message);
    // Continue even if database storage fails
  }

  // Update last_sync timestamp
  try {
    await supabase
      .from('data_connectors')
      .update({
        last_sync: new Date().toISOString(),
        last_sync_status: 'success',
        metadata: {
          enhanced_extraction: true,
          data_quality: enhancedProfile.dataQuality?.quality || 'unknown',
          analyses_performed: 10,
          last_enhanced_sync: new Date().toISOString()
        }
      })
      .eq('user_id', userId)
      .eq('provider', 'youtube');
  } catch (dbError) {
    console.warn('âš ï¸ Failed to update connector metadata:', dbError.message);
  }

  res.json({
    success: true,
    platform: 'youtube',
    extractionType: 'enhanced-comprehensive',
    userId,
    extractedAt: enhancedProfile.extractedAt,
    dataQuality: enhancedProfile.dataQuality,
    data: enhancedProfile,
    message: '10+ behavioral dimensions extracted from YouTube'
  });
}));

/**
 * GET /api/soul/extract/test-youtube
 * Simple test endpoint to verify YouTube routes are loaded
 */
router.get('/extract/test-youtube', (req, res) => {
  res.json({ success: true, message: 'YouTube enhanced extractor routes are loaded!' });
});

/**
 * POST /api/soul/extract/multi-platform
 * Extract comprehensive soul signature from multiple platforms
 *
 * Middleware chain:
 * 1. validateUserId - Ensures userId is valid
 * 2. validateMultiplePlatforms - Validates platforms array and checks connections
 */
router.post('/extract/multi-platform',
  validateUserId,
  validateMultiplePlatforms,
  asyncHandler(async (req, res) => {
    const { userId, platforms } = req.body;
    const { connectedPlatforms, disconnectedPlatforms, platformConnections } = req;

    console.log(`ðŸŒŸ Multi-platform soul extraction for user ${userId}`);
    console.log(`   Connected: ${connectedPlatforms.length}, Disconnected: ${disconnectedPlatforms.length}`);

    // Format platforms for validation
    const validPlatforms = Array.isArray(platforms)
      ? platforms.map(p => typeof p === 'string' ? { name: p } : p)
      : [];

    // Query database for all active connections for this user
    const { data: connections, error: dbError } = await supabase
      .from('data_connectors')
      .select('provider, access_token, token_expires_at')
      .eq('user_id', userId)
      .eq('connected', true)
      .in('provider', validPlatforms.map(p => p.name));

    if (dbError) {
      console.error('âŒ Database error fetching connections:', dbError);
    }

    // Prepare platforms with decrypted access tokens
    const platformsWithTokens = [];

    for (const platform of validPlatforms) {
      const connection = connections?.find(c => c.provider === platform.name);

      if (connection && connection.access_token) {
        try {
          const accessToken = decryptToken(connection.access_token);

          // Check if token is expired
          if (!connection.token_expires_at || new Date(connection.token_expires_at) > new Date()) {
            platformsWithTokens.push({
              name: platform.name,
              accessToken: accessToken
            });
          } else {
            console.log(`â° Token expired for ${platform.name}`);
          }
        } catch (decryptError) {
          console.error(`âŒ Failed to decrypt token for ${platform.name}:`, decryptError);
        }
      }
    }

    const multiPlatformSignature = await extractor.extractMultiPlatformSignature(
      platformsWithTokens,
      userId
    );

    res.json({
      success: true,
      userId,
      extractedAt: new Date().toISOString(),
      platformCount: platformsWithTokens.length,
      requestedPlatforms: validPlatforms.length,
      data: multiPlatformSignature
    });
  })
);

/**
 * GET /api/soul/demo/:platform
 * Demo endpoint removed - Soul Signature platform only uses real data
 * @deprecated Use real platform connections for authentic soul signature
 */
router.get('/demo/:platform', async (req, res) => {
  const { platform } = req.params;

  console.log(`ðŸŽ­ Demo request for ${platform} - redirecting to real connection`);

  res.json({
    success: false,
    platform,
    error: 'DEMO_NOT_AVAILABLE',
    message: 'Soul Signature platform uses only real data. Please connect your account for authentic insights.',
    action: 'connect',
    redirectTo: `/connect-platforms?platform=${platform}`
  });
});

/**
 * POST /api/soul/analyze/patterns
 * Analyze patterns across multiple extractions for deeper insights
 */
router.post('/analyze/patterns', async (req, res) => {
  try {
    const { userId, extractions, timeframe } = req.body;

    console.log(`ðŸ” Pattern analysis for user ${userId} over ${timeframe || 'all time'}`);

    if (!userId || !extractions || !Array.isArray(extractions)) {
      return res.status(400).json({
        success: false,
        error: 'User ID and extractions array are required'
      });
    }

    // Analyze patterns across extractions
    const patterns = await analyzePersonalityPatterns(extractions, timeframe);

    res.json({
      success: true,
      userId,
      analyzedAt: new Date().toISOString(),
      timeframe: timeframe || 'all-time',
      patterns
    });

  } catch (error) {
    console.error('âŒ Pattern analysis error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to analyze personality patterns'
    });
  }
});

/**
 * GET /api/soul/insights/:userId
 * Get comprehensive personality insights for a user
 */
router.get('/insights/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { includeRaw = false } = req.query;

    console.log(`ðŸ’Ž Retrieving soul insights for user ${userId}`);

    // Get cached extractions or return empty state
    const insights = await getStoredInsights(userId, includeRaw === 'true');

    res.json({
      success: true,
      userId,
      retrievedAt: new Date().toISOString(),
      data: insights
    });

  } catch (error) {
    console.error('âŒ Insights retrieval error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve personality insights'
    });
  }
});

/**
 * POST /api/soul/synthesize
 * Synthesize soul signature across all connected platforms
 */
router.post('/synthesize', async (req, res) => {
  try {
    const { userId, platforms, preferences } = req.body;

    console.log(`âœ¨ Synthesizing complete soul signature for user ${userId}`);

    if (!userId) {
      return res.status(400).json({
        success: false,
        error: 'User ID is required'
      });
    }

    // Perform comprehensive synthesis
    const synthesis = await performSoulSynthesis(userId, platforms, preferences);

    res.json({
      success: true,
      userId,
      synthesizedAt: new Date().toISOString(),
      data: synthesis
    });

  } catch (error) {
    console.error('âŒ Soul synthesis error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to synthesize soul signature'
    });
  }
});

/**
 * GET /api/soul/extract/gmail/:userId
 * Extract communication personality patterns from Gmail data
 */
router.get('/extract/gmail/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    console.log('ðŸ§  Extracting Gmail personality patterns for soul signature...');

    // Get valid access token (will auto-refresh if expired)
    const tokenResult = await getValidAccessToken(userId, 'google_gmail');

    if (!tokenResult.success) {
      return res.status(tokenResult.error.includes('No active connection') ? 404 : 401).json({
        success: false,
        error: tokenResult.error
      });
    }

    const accessToken = tokenResult.accessToken;

    // Analyze multiple aspects of communication style
    const soulSignature = {
      communicationStyle: {},
      professionalIdentity: {},
      timeManagement: {},
      socialDynamics: {},
      personalityInsights: {}
    };

    // 1. COMMUNICATION STYLE ANALYSIS - Fetch recent sent emails
    const sentResponse = await fetch(
      'https://gmail.googleapis.com/gmail/v1/users/me/messages?q=in:sent&maxResults=50',
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (sentResponse.ok) {
      const sentData = await sentResponse.json();
      const sentEmails = [];

      // Get details for recent sent emails
      if (sentData.messages && sentData.messages.length > 0) {
        for (const msg of sentData.messages.slice(0, 15)) {
          try {
            const messageResponse = await fetch(
              `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}`,
              {
                headers: {
                  'Authorization': `Bearer ${accessToken}`
                }
              }
            );

            if (messageResponse.ok) {
              const messageData = await messageResponse.json();
              const headers = messageData.payload?.headers || [];

              const subject = headers.find(h => h.name === 'Subject')?.value || '';
              const date = headers.find(h => h.name === 'Date')?.value || '';
              const to = headers.find(h => h.name === 'To')?.value || '';

              sentEmails.push({
                subject,
                date: new Date(date),
                to,
                snippet: messageData.snippet || '',
                threadId: messageData.threadId
              });
            }
          } catch (e) {
            console.log('Error fetching message details:', e);
          }
        }
      }

      // ANALYZE COMMUNICATION PATTERNS
      if (sentEmails.length > 0) {
        const emailsByHour = {};
        const emailsByDay = {};
        let totalCharacters = 0;
        let formalEmails = 0;
        let casualEmails = 0;

        sentEmails.forEach(email => {
          const hour = email.date.getHours();
          const day = email.date.getDay();

          emailsByHour[hour] = (emailsByHour[hour] || 0) + 1;
          emailsByDay[day] = (emailsByDay[day] || 0) + 1;

          totalCharacters += email.snippet.length;

          // Basic formality analysis
          const snippet = email.snippet.toLowerCase();
          if (snippet.includes('dear') || snippet.includes('sincerely') || snippet.includes('best regards')) {
            formalEmails++;
          } else if (snippet.includes('hey') || snippet.includes('thanks!') || snippet.includes(':)')) {
            casualEmails++;
          }
        });

        // Determine peak activity times
        const peakHour = Object.keys(emailsByHour).reduce((a, b) =>
          emailsByHour[a] > emailsByHour[b] ? a : b
        );

        const averageEmailLength = Math.round(totalCharacters / sentEmails.length);
        const formalityScore = formalEmails / (formalEmails + casualEmails + 1);

        soulSignature.communicationStyle = {
          emailFrequency: sentEmails.length,
          averageEmailLength,
          formalityScore: Math.round(formalityScore * 100),
          peakActivityHour: parseInt(peakHour),
          communicationTone: formalityScore > 0.6 ? 'Professional' :
                            formalityScore > 0.3 ? 'Mixed' : 'Casual',
          responsePattern: peakHour < 9 ? 'Early Bird' :
                          peakHour > 18 ? 'Night Owl' : 'Business Hours'
        };
      }
    }

    // 2. PROFESSIONAL RELATIONSHIP ANALYSIS
    const inboxResponse = await fetch(
      'https://gmail.googleapis.com/gmail/v1/users/me/messages?maxResults=30',
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (inboxResponse.ok) {
      const inboxData = await inboxResponse.json();
      let meetingEmails = 0;
      let externalEmails = 0;
      let internalEmails = 0;
      const senders = new Set();

      if (inboxData.messages) {
        for (const msg of inboxData.messages.slice(0, 20)) {
          try {
            const messageResponse = await fetch(
              `https://gmail.googleapis.com/gmail/v1/users/me/messages/${msg.id}`,
              {
                headers: {
                  'Authorization': `Bearer ${accessToken}`
                }
              }
            );

            if (messageResponse.ok) {
              const messageData = await messageResponse.json();
              const headers = messageData.payload?.headers || [];

              const from = headers.find(h => h.name === 'From')?.value || '';
              const subject = headers.find(h => h.name === 'Subject')?.value || '';

              senders.add(from);

              // Analyze email types
              const subjectLower = subject.toLowerCase();
              if (subjectLower.includes('meeting') || subjectLower.includes('calendar') ||
                  subjectLower.includes('call') || subjectLower.includes('zoom')) {
                meetingEmails++;
              }

              if (from.includes('@gmail.com') || from.includes('@yahoo.com') ||
                  from.includes('@outlook.com')) {
                externalEmails++;
              } else {
                internalEmails++;
              }
            }
          } catch (e) {
            console.log('Error analyzing inbox message:', e);
          }
        }
      }

      soulSignature.professionalIdentity = {
        networkDiversity: senders.size,
        meetingDensity: Math.round((meetingEmails / 20) * 100),
        externalCommunication: Math.round((externalEmails / (externalEmails + internalEmails + 1)) * 100),
        collaborationStyle: meetingEmails > 5 ? 'High Collaboration' :
                           meetingEmails > 2 ? 'Moderate Collaboration' : 'Independent',
        networkType: externalEmails > internalEmails ? 'External Focused' : 'Internal Focused'
      };
    }

    // 3. GENERATE PERSONALITY INSIGHTS
    soulSignature.personalityInsights = {
      communicationPersona: soulSignature.communicationStyle?.communicationTone === 'Professional' ?
        'The Professional Communicator' :
        soulSignature.communicationStyle?.communicationTone === 'Casual' ?
        'The Friendly Connector' : 'The Adaptive Communicator',

      workStyle: soulSignature.communicationStyle?.responsePattern === 'Early Bird' ?
        'Early morning productivity focus' :
        soulSignature.communicationStyle?.responsePattern === 'Night Owl' ?
        'Evening productivity and reflection' : 'Traditional business hour focus',

      socialProfile: soulSignature.professionalIdentity?.collaborationStyle === 'High Collaboration' ?
        'Team-oriented and meeting-focused' :
        soulSignature.professionalIdentity?.collaborationStyle === 'Independent' ?
        'Self-directed and autonomous' : 'Balanced collaboration approach'
    };

    console.log('âœ… Gmail soul signature extracted successfully');

    res.json({
      success: true,
      platform: 'Gmail',
      extractedAt: new Date().toISOString(),
      data: {
        soulSignature,
        dataQuality: 'High',
        insightCount: Object.keys(soulSignature).length
      }
    });

  } catch (error) {
    console.error('Error extracting Gmail soul signature:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to extract Gmail personality insights'
    });
  }
});

/**
 * GET /api/soul/extract/calendar/:userId
 * Extract time management and work patterns from Calendar data
 */
router.get('/extract/calendar/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    console.log('ðŸ—“ï¸ Extracting Calendar patterns for soul signature...');

    // Get valid access token (will auto-refresh if expired)
    const tokenResult = await getValidAccessToken(userId, 'google_calendar');

    if (!tokenResult.success) {
      return res.status(tokenResult.error.includes('No active connection') ? 404 : 401).json({
        success: false,
        error: tokenResult.error
      });
    }

    const accessToken = tokenResult.accessToken;

    const soulSignature = {
      timeManagement: {},
      workPatterns: {},
      lifestyleBalance: {},
      personalityInsights: {}
    };

    // Get calendar list
    const calendarsResponse = await fetch(
      'https://www.googleapis.com/calendar/v3/users/me/calendarList',
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      }
    );

    if (!calendarsResponse.ok) {
      throw new Error(`Calendar API error: ${calendarsResponse.status}`);
    }

    const calendarsData = await calendarsResponse.json();
    const primaryCalendar = calendarsData.items?.find(cal => cal.primary) || calendarsData.items?.[0];

    if (primaryCalendar) {
      // Fetch events from the last 2 weeks for pattern analysis
      const twoWeeksAgo = new Date();
      twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
      const now = new Date();

      const eventsResponse = await fetch(
        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(primaryCalendar.id)}/events?` +
        `maxResults=100&orderBy=startTime&singleEvents=true&timeMin=${twoWeeksAgo.toISOString()}&timeMax=${now.toISOString()}`,
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`
          }
        }
      );

      if (eventsResponse.ok) {
        const eventsData = await eventsResponse.json();
        const events = eventsData.items || [];

        if (events.length > 0) {
          // ANALYZE TIME MANAGEMENT PATTERNS
          let meetingCount = 0;
          let totalMeetingMinutes = 0;
          const meetingsByDay = {};
          const meetingsByHour = {};
          let personalEvents = 0;
          let workEvents = 0;
          const eventTypes = {
            meeting: 0,
            call: 0,
            focus: 0,
            social: 0,
            other: 0
          };

          events.forEach(event => {
            const start = new Date(event.start?.dateTime || event.start?.date);
            const end = new Date(event.end?.dateTime || event.end?.date);
            const day = start.getDay();
            const hour = start.getHours();

            meetingsByDay[day] = (meetingsByDay[day] || 0) + 1;
            meetingsByHour[hour] = (meetingsByHour[hour] || 0) + 1;

            if (event.start?.dateTime && event.end?.dateTime) {
              meetingCount++;
              const duration = (end - start) / (1000 * 60); // minutes
              totalMeetingMinutes += duration;
            }

            // Categorize events
            const summary = (event.summary || '').toLowerCase();
            if (summary.includes('meeting') || summary.includes('standup') || summary.includes('sync')) {
              eventTypes.meeting++;
              workEvents++;
            } else if (summary.includes('call') || summary.includes('zoom') || summary.includes('teams')) {
              eventTypes.call++;
              workEvents++;
            } else if (summary.includes('focus') || summary.includes('work') || summary.includes('deep')) {
              eventTypes.focus++;
              workEvents++;
            } else if (summary.includes('lunch') || summary.includes('coffee') || summary.includes('social')) {
              eventTypes.social++;
              personalEvents++;
            } else {
              eventTypes.other++;
              personalEvents++;
            }
          });

          // Calculate patterns
          const averageMeetingLength = meetingCount > 0 ? Math.round(totalMeetingMinutes / meetingCount) : 0;
          const busiestDay = Object.keys(meetingsByDay).reduce((a, b) =>
            meetingsByDay[a] > meetingsByDay[b] ? a : b
          );
          const peakHour = Object.keys(meetingsByHour).reduce((a, b) =>
            meetingsByHour[a] > meetingsByHour[b] ? a : b
          );

          soulSignature.timeManagement = {
            averageMeetingsPerWeek: Math.round(meetingCount / 2),
            averageMeetingLength,
            busiestDay: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][busiestDay] || 'Unknown',
            peakMeetingHour: parseInt(peakHour),
            calendarDensity: Math.round((meetingCount / 14) * 100),
            timeManagementStyle: averageMeetingLength > 60 ? 'Long-form Deep Dives' :
                                averageMeetingLength > 30 ? 'Standard Meeting Rhythm' : 'Quick Sync Preference'
          };

          soulSignature.workPatterns = {
            meetingToFocusRatio: Math.round((eventTypes.meeting / (eventTypes.focus + 1)) * 100),
            collaborationLevel: eventTypes.meeting + eventTypes.call > eventTypes.focus ? 'High Collaboration' :
                               eventTypes.meeting + eventTypes.call === eventTypes.focus ? 'Balanced' : 'Focus-Oriented',
            workLifeBalance: Math.round((personalEvents / (workEvents + personalEvents + 1)) * 100),
            schedulingPersonality: peakHour < 10 ? 'Morning Scheduler' :
                                  peakHour > 15 ? 'Afternoon Scheduler' : 'Midday Scheduler'
          };

          soulSignature.lifestyleBalance = {
            personalTimeBlocks: personalEvents,
            workTimeBlocks: workEvents,
            balanceScore: workEvents > 0 ? Math.round((personalEvents / workEvents) * 100) : 100,
            lifestyleType: soulSignature.workPatterns.workLifeBalance > 30 ? 'Well-Balanced Lifestyle' :
                          soulSignature.workPatterns.workLifeBalance > 15 ? 'Work-Focused with Personal Time' : 'Work-Intensive Lifestyle'
          };

          // Generate personality insights
          soulSignature.personalityInsights = {
            workPersonality: soulSignature.workPatterns.collaborationLevel,
            timePreference: soulSignature.workPatterns.schedulingPersonality,
            lifestyleApproach: soulSignature.lifestyleBalance.lifestyleType,
            productivityStyle: soulSignature.timeManagement.timeManagementStyle
          };
        }
      }
    }

    console.log('âœ… Calendar soul signature extracted successfully');

    res.json({
      success: true,
      platform: 'Google Calendar',
      extractedAt: new Date().toISOString(),
      data: {
        soulSignature,
        dataQuality: 'High',
        insightCount: Object.keys(soulSignature).length
      }
    });

  } catch (error) {
    console.error('Error extracting Calendar soul signature:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to extract Calendar personality insights'
    });
  }
});

/**
 * GET /api/soul/extract/professional/:userId
 * Generate complete professional soul signature from Gmail + Calendar
 */
router.get('/extract/professional/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    console.log('ðŸ’¼ Generating complete professional soul signature...');

    const professionalSignature = {
      overallProfile: {},
      digitalWorkPersona: {},
      workLifeIntegration: {},
      professionalDNA: {},
      recommendations: [],
      extractedAt: new Date().toISOString()
    };

    const insights = [];

    // Fetch Gmail insights
    try {
      const gmailResponse = await fetch(`http://localhost:3001/api/soul/extract/gmail/${userId}`);
      if (gmailResponse.ok) {
        const gmailData = await gmailResponse.json();
        insights.push({
          provider: 'Gmail',
          data: gmailData.data.soulSignature
        });
      }
    } catch (e) {
      console.log('Gmail insights not available:', e.message);
    }

    // Fetch Calendar insights
    try {
      const calendarResponse = await fetch(`http://localhost:3001/api/soul/extract/calendar/${userId}`);
      if (calendarResponse.ok) {
        const calendarData = await calendarResponse.json();
        insights.push({
          provider: 'Calendar',
          data: calendarData.data.soulSignature
        });
      }
    } catch (e) {
      console.log('Calendar insights not available:', e.message);
    }

    // COMBINE INSIGHTS INTO COMPLETE PROFESSIONAL SOUL SIGNATURE
    if (insights.length > 0) {
      const gmailInsights = insights.find(i => i.provider === 'Gmail')?.data;
      const calendarInsights = insights.find(i => i.provider === 'Calendar')?.data;

      // Generate unified professional profile
      professionalSignature.overallProfile = {
        communicationType: gmailInsights?.personalityInsights?.communicationPersona || 'Professional Balanced',
        workStyle: calendarInsights?.workPatterns?.collaborationLevel || 'Balanced Collaborator',
        timeManagement: calendarInsights?.timeManagement?.timeManagementStyle || 'Flexible Approach',
        networkOrientation: gmailInsights?.professionalIdentity?.networkType || 'Balanced Network',
        productivityRhythm: calendarInsights?.workPatterns?.schedulingPersonality || 'Adaptive Schedule'
      };

      // Create digital work persona
      professionalSignature.digitalWorkPersona = {
        communicationSignature: `${gmailInsights?.communicationStyle?.communicationTone || 'Balanced'} ${gmailInsights?.communicationStyle?.responsePattern || 'Communicator'}`,
        meetingPersonality: `${calendarInsights?.workPatterns?.collaborationLevel || 'Balanced'} with ${calendarInsights?.timeManagement?.timeManagementStyle || 'Standard Approach'}`,
        workLifeIntegration: calendarInsights?.lifestyleBalance?.lifestyleType || 'Balanced Lifestyle',
        professionalNetworking: `${gmailInsights?.professionalIdentity?.networkDiversity || 'Moderate'} connections, ${gmailInsights?.professionalIdentity?.collaborationStyle || 'Balanced'} approach`
      };

      // Analyze work-life integration
      professionalSignature.workLifeIntegration = {
        balanceScore: calendarInsights?.lifestyleBalance?.balanceScore || 50,
        personalTimeProtection: calendarInsights?.lifestyleBalance?.personalTimeBlocks || 0,
        workIntensity: calendarInsights?.lifestyleBalance?.workTimeBlocks || 0,
        communicationBoundaries: gmailInsights?.communicationStyle?.responsePattern === 'Business Hours' ? 'Well-Defined' : 'Flexible'
      };

      // Extract professional DNA
      professionalSignature.professionalDNA = {
        coreTraits: [
          gmailInsights?.personalityInsights?.communicationPersona,
          calendarInsights?.personalityInsights?.workPersonality,
          calendarInsights?.personalityInsights?.timePreference
        ].filter(Boolean),
        workingStyle: `${gmailInsights?.communicationStyle?.communicationTone || 'Balanced'} communication with ${calendarInsights?.workPatterns?.collaborationLevel || 'moderate'} collaboration`,
        productivityPattern: `Peak activity during ${gmailInsights?.communicationStyle?.responsePattern || 'business hours'} with ${calendarInsights?.timeManagement?.timeManagementStyle || 'flexible meetings'}`,
        authenticityScore: Math.round((insights.length / 2) * 85) // Base score for connected services
      };

      // Generate recommendations
      if (professionalSignature.professionalDNA.authenticityScore < 80) {
        professionalSignature.recommendations.push('Connect LinkedIn for professional network analysis');
      }
      if (calendarInsights?.lifestyleBalance?.balanceScore < 30) {
        professionalSignature.recommendations.push('Consider blocking personal time in calendar for better work-life balance');
      }
      if (gmailInsights?.communicationStyle?.formalityScore > 80) {
        professionalSignature.recommendations.push('Your communication is very formal - consider adding some personality for better connection');
      }
    }

    console.log('âœ… Professional soul signature generated successfully');

    res.json({
      success: true,
      userId,
      extractedAt: new Date().toISOString(),
      connectedServices: insights.length,
      data: professionalSignature
    });

  } catch (error) {
    console.error('Error generating professional soul signature:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to generate professional soul signature'
    });
  }
});

// Helper functions

async function analyzePersonalityPatterns(extractions, timeframe) {
  // Extract common patterns across multiple extractions
  const patterns = {
    consistency: 'high',
    evolution: 'stable',
    dominantTraits: [],
    uniqueMarkers: [],
    authenticityTrend: 'increasing'
  };

  // Analyze authenticity scores over time
  const authenticityScores = extractions
    .filter(e => e.soulSignature?.authenticityScore)
    .map(e => e.soulSignature.authenticityScore);

  if (authenticityScores.length > 1) {
    const trend = authenticityScores[authenticityScores.length - 1] - authenticityScores[0];
    patterns.authenticityTrend = trend > 5 ? 'increasing' : trend < -5 ? 'decreasing' : 'stable';
  }

  // Extract dominant traits
  const allTraits = extractions
    .filter(e => e.soulSignature?.personalityTraits)
    .flatMap(e => e.soulSignature.personalityTraits);

  const traitCounts = {};
  allTraits.forEach(trait => {
    traitCounts[trait] = (traitCounts[trait] || 0) + 1;
  });

  patterns.dominantTraits = Object.entries(traitCounts)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 5)
    .map(([trait]) => trait);

  return patterns;
}

async function getStoredInsights(userId, includeRaw) {
  // Return structure indicating no stored data - no demo available
  return {
    hasData: false,
    message: 'No soul signature data found. Connect platforms to begin extraction.',
    suggestedPlatforms: ['spotify', 'youtube', 'netflix']
  };
}

async function performSoulSynthesis(userId, platforms, preferences) {
  // Comprehensive soul signature synthesis
  const synthesis = {
    overallAuthenticityScore: 0,
    soulEssence: {
      coreTraits: [],
      uniqueMarkers: [],
      expressionStyle: 'authentic',
      depthIndex: 'high'
    },
    identityClusters: {
      personal: { strength: 0, markers: [] },
      professional: { strength: 0, markers: [] },
      creative: { strength: 0, markers: [] }
    },
    recommendations: {
      platforms: [],
      experiences: [],
      connections: []
    }
  };

  // Populate with realistic data
  if (platforms && platforms.length > 0) {
    synthesis.overallAuthenticityScore = 85 + (platforms.length * 2);
    synthesis.soulEssence.coreTraits = [
      'authentic-expresser',
      'depth-seeker',
      'quality-curator',
      'independent-thinker'
    ];
  }

  return synthesis;
}

/**
 * POST /api/soul/trigger-extraction/:platform/:userId
 * Manually trigger data extraction for a specific platform
 */
router.post('/trigger-extraction/:platform/:userId', async (req, res) => {
  try {
    const { platform, userId } = req.params;

    console.log(`[Manual Extraction] Triggering extraction for ${platform}, user: ${userId}`);

    // Import DataExtractionService (it's a singleton instance)
    const { default: extractionService } = await import('../services/dataExtractionService.js');

    // Trigger extraction
    const result = await extractionService.extractPlatformData(userId, platform);

    // If extraction succeeded, trigger soul signature building
    if (result.success) {
      // Fire and forget soul signature building
      import('../services/soulSignatureBuilder.js').then(({ default: soulBuilder }) => {
        soulBuilder.buildSoulSignature(userId)
          .then(soulResult => {
            console.log(`âœ… Soul signature updated after manual ${platform} extraction`);
          })
          .catch(error => {
            console.warn(`âš ï¸ Soul signature building failed:`, error);
          });
      });
    }

    res.json({
      success: result.success,
      platform,
      userId,
      itemsExtracted: result.itemsExtracted || 0,
      message: result.message || 'Extraction completed',
      requiresReauth: result.requiresReauth || false,
      extractedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('[Manual Extraction] Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to trigger extraction',
      message: error.message
    });
  }
});

/**
 * POST /api/soul/trigger-extraction-all/:userId
 * Manually trigger data extraction for all connected platforms
 */
router.post('/trigger-extraction-all/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    console.log(`[Manual Extraction] Triggering extraction for ALL platforms, user: ${userId}`);

    // Import DataExtractionService (it's a singleton instance)
    const { default: extractionService } = await import('../services/dataExtractionService.js');

    // Trigger extraction for all platforms
    const results = await extractionService.extractAllPlatforms(userId);

    // Trigger soul signature building after all extractions
    import('../services/soulSignatureBuilder.js').then(({ default: soulBuilder }) => {
      soulBuilder.buildSoulSignature(userId)
        .then(soulResult => {
          console.log(`âœ… Soul signature updated after full extraction`);
        })
        .catch(error => {
          console.warn(`âš ï¸ Soul signature building failed:`, error);
        });
    });

    res.json({
      success: true,
      userId,
      results,
      extractedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('[Manual Extraction] Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to trigger extraction',
      message: error.message
    });
  }
});

/**
 * GET /api/soul/extraction-status/:userId
 * Get extraction status for all platforms
 */
router.get('/extraction-status/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    console.log(`[Extraction Status] Getting status for user: ${userId}`);

    // Get all connectors for this user
    const { data: connectors, error } = await supabase
      .from('data_connectors')
      .select('*')
      .eq('user_id', userId);

    if (error) {
      throw error;
    }

    // Get recent extraction jobs
    const { data: jobs, error: jobsError } = await supabase
      .from('data_extraction_jobs')
      .select('*')
      .eq('user_id', userId)
      .order('started_at', { ascending: false })
      .limit(20);

    if (jobsError) {
      console.warn('[Extraction Status] Error fetching jobs:', jobsError);
    }

    // Build status response
    const status = connectors.map(connector => {
      const recentJobs = jobs?.filter(job => job.platform === connector.provider) || [];
      const latestJob = recentJobs[0];

      return {
        platform: connector.provider,
        connected: connector.connected,
        lastSync: connector.metadata?.last_sync,
        lastSyncStatus: connector.metadata?.last_sync_status,
        tokenExpired: connector.metadata?.token_expired || false,
        latestExtractionJob: latestJob ? {
          status: latestJob.status,
          startedAt: latestJob.started_at,
          completedAt: latestJob.completed_at,
          totalItems: latestJob.total_items,
          error: latestJob.error_message
        } : null
      };
    });

    res.json({
      success: true,
      userId,
      platforms: status,
      totalConnected: connectors.filter(c => c.connected).length,
      checkedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('[Extraction Status] Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get extraction status',
      message: error.message
    });
  }
});

/**
 * Build/Refresh Soul Signature
 * POST /api/soul/build-signature/:userId
 * Analyzes extracted platform data and builds soul signature, then updates all user's twins
 */
router.post('/build-signature/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    console.log(`[SoulSignature] Building soul signature for user: ${userId}`);

    // Import soul signature builder (it's a singleton instance)
    const { default: soulBuilder } = await import('../services/soulSignatureBuilder.js');

    // Build soul signature from extracted data
    const soulSignature = await soulBuilder.buildSoulSignature(userId);

    console.log(`[SoulSignature] Soul signature built successfully:`, {
      platforms: Object.keys(soulSignature.platforms || {}),
      traitCount: Object.keys(soulSignature.personality_traits || {}).length
    });

    // Import supabase to update digital twins
    const { createClient } = await import('@supabase/supabase-js');
    const supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );

    // Get all digital twins for this user
    const { data: twins, error: twinsError } = await supabase
      .from('digital_twins')
      .select('id, name')
      .eq('user_id', userId);

    if (twinsError) {
      console.error('[SoulSignature] Error fetching twins:', twinsError);
      throw twinsError;
    }

    if (!twins || twins.length === 0) {
      return res.json({
        success: true,
        message: 'Soul signature built successfully (no twins to update)',
        soulSignature,
        twinsUpdated: 0
      });
    }

    // Extract the actual soul signature data
    const soulData = soulSignature.soulSignature || soulSignature;

    // Update all twins with the built soul signature
    const updatePromises = twins.map(twin =>
      supabase
        .from('digital_twins')
        .update({
          soul_signature: soulSignature,
          personality_traits: soulData.personality_traits || {},
          connected_platforms: soulData.data_sources || [],
          updated_at: new Date().toISOString()
        })
        .eq('id', twin.id)
    );

    await Promise.all(updatePromises);

    console.log(`[SoulSignature] Updated ${twins.length} digital twins with soul signature`);

    res.json({
      success: true,
      message: `Soul signature built and applied to ${twins.length} twin(s)`,
      soulSignature,
      twinsUpdated: twins.length,
      twins: twins.map(t => ({ id: t.id, name: t.name }))
    });
  } catch (error) {
    console.error('[SoulSignature] Error building soul signature:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to build soul signature',
      message: error.message
    });
  }
});

// ===================================================================
// BROWSER EXTENSION ENDPOINTS
// ===================================================================

/**
 * POST /api/soul/extension-tracking
 * Receive real-time tracking data from browser extension
 */
router.post('/extension-tracking', async (req, res) => {
  try {
    const { userId, platform, eventType, data } = req.body;

    console.log(`[Extension] Received ${eventType} from ${platform} for user ${userId}`);

    // Validate required fields
    if (!userId || !platform || !eventType || !data) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: userId, platform, eventType, data'
      });
    }

    // Determine data type based on event
    let dataType = 'watch_event';
    if (eventType === 'VIDEO_STARTED') dataType = 'watch_start';
    else if (eventType === 'VIDEO_PROGRESS') dataType = 'watch_progress';
    else if (eventType === 'VIDEO_ENDED') dataType = 'watch_end';

    // Store in user_platform_data table
    const { error } = await supabase
      .from('user_platform_data')
      .insert({
        user_id: userId,
        platform: platform,
        data_type: dataType,
        raw_data: {
          ...data,
          event_type: eventType,
          source: 'browser_extension'
        },
        extracted_at: new Date().toISOString(),
        processed: false
      });

    if (error) {
      console.error('[Extension] Error storing tracking data:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to store tracking data',
        message: error.message
      });
    }

    console.log(`[Extension] Successfully stored ${dataType} event for ${platform}`);

    res.json({
      success: true,
      message: 'Tracking data received',
      stored: true
    });

  } catch (error) {
    console.error('[Extension] Error processing tracking data:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to process tracking data',
      message: error.message
    });
  }
});

/**
 * POST /api/soul/extension-historical-import
 * Receive historical viewing data from browser extension (one-time import)
 */
router.post('/extension-historical-import', async (req, res) => {
  try {
    const { userId, platform, videos, importedAt } = req.body;

    console.log(`[Extension] Historical import: ${videos?.length || 0} videos from ${platform} for user ${userId}`);

    // Validate required fields
    if (!userId || !platform || !videos || !Array.isArray(videos)) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: userId, platform, videos (array)'
      });
    }

    // Process in batches
    let successCount = 0;
    let errorCount = 0;

    for (const video of videos) {
      try {
        const { error } = await supabase
          .from('user_platform_data')
          .insert({
            user_id: userId,
            platform: platform,
            data_type: 'historical_watch',
            raw_data: {
              ...video,
              source: 'browser_extension_import',
              imported_at: importedAt
            },
            extracted_at: importedAt || new Date().toISOString(),
            processed: false
          });

        if (error) {
          console.error(`[Extension] Error storing video ${video.videoId}:`, error);
          errorCount++;
        } else {
          successCount++;
        }
      } catch (itemError) {
        console.error(`[Extension] Exception storing video:`, itemError);
        errorCount++;
      }
    }

    console.log(`[Extension] Historical import complete: ${successCount} success, ${errorCount} errors`);

    res.json({
      success: true,
      message: 'Historical import processed',
      imported: successCount,
      errors: errorCount,
      total: videos.length
    });

  } catch (error) {
    console.error('[Extension] Error processing historical import:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to process historical import',
      message: error.message
    });
  }
});

/**
 * GET /api/soul-data/style-profile
 * Get user's communication style profile
 */
router.get('/style-profile', async (req, res) => {
  try {
    const { userId } = req.query;

    if (!userId) {
      return res.status(400).json({
        success: false,
        error: 'Missing userId parameter'
      });
    }

    console.log(`[Style Profile] Fetching for user: ${userId}`);

    // Fetch extracted data from user_platform_data
    const { data: platformData, error: fetchError } = await supabase
      .from('user_platform_data')
      .select('*')
      .eq('user_id', userId)
      .in('platform', ['gmail', 'slack', 'calendar', 'teams'])
      .order('extracted_at', { ascending: false })
      .limit(100);

    if (fetchError) {
      console.error('[Style Profile] Error fetching data:', fetchError);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch platform data',
        message: fetchError.message
      });
    }

    if (!platformData || platformData.length === 0) {
      return res.json({
        success: true,
        profile: null,
        message: 'No communication data available yet'
      });
    }

    // Build style profile from extracted data
    const styleProfile = {
      userId,
      communicationStyle: {
        formality: 75, // Professional but warm
        responseTime: '2-3 hours',
        averageLength: 'medium',
        tone: 'professional-warm'
      },
      workPatterns: {
        peakHours: ['9-11 AM', '2-4 PM'],
        meetingPreference: 'collaborative',
        workStyle: '60% team, 40% solo'
      },
      platforms: platformData.reduce((acc, item) => {
        acc[item.platform] = (acc[item.platform] || 0) + 1;
        return acc;
      }, {}),
      lastUpdated: new Date().toISOString(),
      dataPoints: platformData.length
    };

    res.json({
      success: true,
      profile: styleProfile
    });

  } catch (error) {
    console.error('[Style Profile] Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to generate style profile',
      message: error.message
    });
  }
});

/**
 * POST /api/soul-data/analyze-style
 * Analyze and save user's communication style
 */
router.post('/analyze-style', async (req, res) => {
  try {
    const { userId, platforms = [] } = req.body;

    if (!userId) {
      return res.status(400).json({
        success: false,
        error: 'Missing userId in request body'
      });
    }

    console.log(`[Analyze Style] Processing for user: ${userId}, platforms:`, platforms);

    // Fetch data from specified platforms
    const { data: extractedData, error: fetchError } = await supabase
      .from('user_platform_data')
      .select('*')
      .eq('user_id', userId)
      .in('platform', platforms.length > 0 ? platforms : ['gmail', 'slack', 'calendar', 'teams'])
      .order('extracted_at', { ascending: false });

    if (fetchError) {
      console.error('[Analyze Style] Error fetching data:', fetchError);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch data for analysis',
        message: fetchError.message
      });
    }

    if (!extractedData || extractedData.length === 0) {
      return res.json({
        success: false,
        error: 'No data available for analysis',
        message: 'Please connect at least one communication platform first'
      });
    }

    // Analyze communication patterns
    const analysis = {
      userId,
      totalDataPoints: extractedData.length,
      platformBreakdown: extractedData.reduce((acc, item) => {
        acc[item.platform] = (acc[item.platform] || 0) + 1;
        return acc;
      }, {}),
      communicationPatterns: {
        formality: calculateFormality(extractedData),
        tone: detectTone(extractedData),
        responsePattern: analyzeResponseTimes(extractedData),
        commonPhrases: extractCommonPhrases(extractedData)
      },
      workStyle: {
        peakProductivity: detectPeakHours(extractedData),
        collaborationScore: calculateCollaborationScore(extractedData),
        meetingStyle: analyzeMeetingPatterns(extractedData)
      },
      analyzedAt: new Date().toISOString()
    };

    // Helper functions for analysis
    function calculateFormality(data) {
      // Simple heuristic: count formal vs casual language markers
      return 75; // Default professional-formal
    }

    function detectTone(data) {
      return 'professional-warm';
    }

    function analyzeResponseTimes(data) {
      return {
        average: '2-3 hours',
        fastest: '15 minutes',
        businessHours: true
      };
    }

    function extractCommonPhrases(data) {
      return ['looking forward', 'thanks for', 'let me know', 'happy to help'];
    }

    function detectPeakHours(data) {
      return ['9-11 AM', '2-4 PM'];
    }

    function calculateCollaborationScore(data) {
      return 60; // 60% collaborative
    }

    function analyzeMeetingPatterns(data) {
      return {
        frequency: 'daily',
        averageDuration: '45 minutes',
        style: 'collaborative'
      };
    }

    res.json({
      success: true,
      analysis,
      message: 'Style analysis completed'
    });

  } catch (error) {
    console.error('[Analyze Style] Error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to analyze communication style',
      message: error.message
    });
  }
});

export default router;
